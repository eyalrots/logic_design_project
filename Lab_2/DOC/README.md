# Lab 2 - Verification

## DUT

### fsm.sv:
* top design file.
* implements a synchronous FSM design as follows:
> RESET -> CASE_1 -> CASE_2 -> CASE_3
* The cases:
    * RESET: Resets all register to 0. consequently it resets the outputs too, but one clock cycle ahead since the output is registered.
    * CASE_1: Saves the `sub_bytes` output matrix (actually the shiter output) to the apropriate register - `sb_mat`.
    * CASE_2: saves the `mix_columns` calculation to the appropriate register - `mix_mat_r`.
    * CASE_3: Idle state for `done` and for stabilizing the output.
* The output data is conditioned by `done` being high as can be seeing in the code:
 ```systemverilog
 assign mix_out = done ? mix_mat_r : zero_mat;
```
In which `zero_mat` is just a matrix of zeros.

*The rest of the design is the same as before.*

## TB

### fsm_tb.sv
* This is the main verification file.
* It encorporates several verification technics:
    * BFM: here we insert `random` vectors as inouts to the main `dut` module and test the output againsts the `golden model` anticipated output. We also track our successes and fails with relation to the `goldem model`.
    * Assertions: Here we check specific conditions to see if our`FSM` logic behaves as expected. an example:
    ```systemverilog
    property check_reset_clears_output;
        @(posedge clk)
        (dut.state == dut.RESET) |=> (dut.mix_out == zero_mat && dut.done_out == 0);
    endproperty

    assert property (check_reset_clears_output)
        else $error("[Assersion failed] Outputs are not 0 during RESET state.");
    ```
    * Coverage: This part is similar to the Assersions, it check the FSM behaviour by counting how many times the system was in each `state` and how many transisions happened between states. This helps us understand is the synchronous behaviuor of the `FSM` is met. Here is a code example:
    ```systemverilog
    covergroup fsm_transitions @(posedge clk);
        coverpoint but.state {
            bins reset_to_case_1 = (dut.RESET => dut.CASE_1);
            .
            .
            .
        }
    endgroup

    fsm_transitions cg_trans = new();
    ```

### golden_model.py
This is the golden model of the desig. It encorporates all design functionality, written in a high-level language (`python`). Agains this models outputs we check our `verilog` design to see if it's correcet (in the `BFM` stage).

### golden_model_questa_out.memb
This file is the output of the `golden model` for the questa-(randomly)generated input vector (for the design).

### golden_model_modelsim_out.memb
This file is the output of the `golden model` for the ModelSim-(randomly)generated input vectors.

## TB/coverage

### coverage_report.txt
This is the text file version of the coverage report as generated by QuesteSim.

### my_coverage.ucdb
The standard file-type for coverage output database as generated by QuestaSim.

### TB/coverage/html_report
This is an html interructive version of the coverage report.
> In order to run this please open the file `idex.html`.